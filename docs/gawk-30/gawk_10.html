<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0 Strict Level 2//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html;charset=iso-2022-jp">
<!-- This HTML file has been created by texi2html 1.47
     from gawk.tex on 10 文月 1999 -->

<TITLE>The GNU Awk User's Guide - アクション中の制御文</TITLE>
</HEAD>
<BODY>
移動先 <A HREF="gawk_1.html">先頭</A>, <A HREF="gawk_9.html">前</A>, <A HREF="gawk_11.html">次</A>, <A HREF="gawk_25.html">末尾</A> セクション, <A HREF="gawk_toc.html">目次</A>.
<HR>


<H1><A NAME="SEC98" HREF="gawk_toc.html#SEC98">アクション中の制御文</A></H1>
<P>
<A NAME="IDX424"></A>

</P>
<P>
<CODE>if</CODE>や<CODE>while</CODE>などの<STRONG>制御文</STRONG>(control statement)は、
<CODE>awk</CODE>プログラムの実行の流れを制御する。
<CODE>awk</CODE>の制御文のほとんどはCで使われているものと
同じ形式である。

</P>
<P>
すべての制御文は単純な式と区別するために、
<CODE>if</CODE>や<CODE>while</CODE>などのような特別なキーワードで始まる。

</P>
<P>
<A NAME="IDX425"></A>
<A NAME="IDX426"></A>
多くの制御文は他の文を構成要素に持っている。例えば<CODE>if</CODE>文は
実行されたりされなかったりする<CODE>body</CODE>と呼ばれるような
別の文を持っている。
もし<CODE>body</CODE>に二つ以上の文を含めたいのであれば、カーリーブレースを
使うことにより、セミコロンや改行で区切られた文の集まりを一つの
<STRONG>複合文</STRONG>としてまとめることができる。

</P>



<H2><A NAME="SEC99" HREF="gawk_toc.html#SEC99">The <CODE>if</CODE>-<CODE>else</CODE> Statement</A></H2>

<P>
<A NAME="IDX427"></A>
<CODE>if</CODE>-<CODE>else</CODE>文は意思決定をする文であり、
次のような形をしている。

</P>

<PRE>
if (<VAR>condition</VAR>) <VAR>then-body</VAR> [else <VAR>else-body</VAR>]
</PRE>

<P>
<VAR>condition</VAR>は文の残りの部分を制御する式である。もし<VAR>condition</VAR>が真で
あれば<VAR>then-body</VAR>が実行され、偽であれば<VAR>else-body</VAR>が実行される。
<CODE>else</CODE>部分は省略可能である。
<VAR>condition</VAR>はその値が0か空文字列であれば偽として見なされ、それ以外の値は
真であると見なされる。

</P>
<P>
例を挙げよう。

</P>

<PRE>
if (x % 2 == 0)
    print "x is even"
else
    print "x is odd"
</PRE>

<P>
この例では、<CODE>x % 2 == 0</CODE>という式が真である(つまり、 <CODE>x</CODE>が 2で割り
切れる値である)ときに、最初の<CODE>print</CODE>文を実行し、そうでない(2で割り切
れない)ときに二番目の<CODE>print</CODE>文を実行する。

</P>
<P>
<CODE>else</CODE>が<VAR>then-body</VAR>と同じ行にあり、<VAR>then-body</VAR>が複合文でない
(カーリーブレースで囲まれていない)とき、セミコロンで <VAR>then-body</VAR> と
<CODE>else</CODE>を区切らなければならない。この規則により、先の例は次のように書け
る。

</P>

<PRE>
if (x % 2 == 0) print "x is even"; else
        print "x is odd"
</PRE>

<P>
ここで<SAMP>`;'</SAMP>を付け忘れてしまった場合、<CODE>awk</CODE>は構文解析を続けられなくな
り、シンタックスエラーとなる。

</P>
<P>
我々は実際にはこの例のような書き方はしない。なぜなら人が読むときに、行の最初に
なければ<CODE>else</CODE>を読み落す可能性があるからである。

</P>


<H2><A NAME="SEC100" HREF="gawk_toc.html#SEC100">The <CODE>while</CODE> Statement</A></H2>
<P>
<A NAME="IDX428"></A>
<A NAME="IDX429"></A>
<A NAME="IDX430"></A>

</P>
<P>
プログラミングにおいては、<STRONG>ループ</STRONG>とはプログラムの一部分を二回以上実行す
る(少なくともその可能性がある)ことである。

</P>
<P>
<CODE>while</CODE>文は<CODE>awk</CODE>の中で最も単純な繰り返しの文である。条件が真である
間、文を繰り返し実行する。 <CODE>while</CODE>文は次のような形をしている。

</P>

<PRE>
while (<VAR>condition</VAR>)
  <VAR>body</VAR>
</PRE>

<P>
ここで<VAR>body</VAR>は我々が繰り返しの本体と呼んでいる文であり、
<VAR>condition</VAR>はどれ位の間繰り返しを続けるかを制御する式である。

</P>
<P>
<CODE>while</CODE>文で最初に行なわれるのは<VAR>condition</VAR>の検査である。もし
<VAR>condition</VAR>が真であれば<VAR>body</VAR>の文を実行する。
<VAR>body</VAR>を実行したあとで、再び
<VAR>condition</VAR>をテストし、それがまだ真であれば<VAR>body</VAR>が実行される。この
プロセスは<VAR>condition</VAR>が真でなくなるまで繰りかえされる。 <VAR>condition</VAR>
が最初に偽であった場合、ループの本体は決して実行されなず、<CODE>awk</CODE>は
ループに続く文に移る。

</P>
<P>
次の例は、入力行の最初の三つのフィールドを一行にフィールドひとつという形で出
力する。

</P>

<PRE>
awk '{ i = 1
       while (i &#60;= 3) {
           print $i
           i++
       }
}' inventory-shipped
</PRE>

<P>
ここでループの本体は二つの文をカーリーブレースでくくった複合文である。

</P>
<P>
ループは次のように動作する。最初に<CODE>i</CODE>の値を1にセットし、その後に
<CODE>while</CODE>が<CODE>i</CODE>が3以下であるかどうかを検査する。 <CODE>i</CODE>がある数字で
あったとき、<CODE>i</CODE>番目のフィールドが出力される。<CODE>i++</CODE>によって<CODE>i</CODE>
の値が増やされて、ループが繰り返される。ループは<CODE>i</CODE>が4になったときに終
了する。

</P>
<P>
例を見るとわかる通り、改行は条件と本体の間になくても良い。しかし、本体が複合
文か非常に単純なものでない限り、改行を入れることによってプログラムの見通しが
よくなる。複合文の初めにある左カーリーブレースのあとの改行はなくても構わない
が、プログラムが読み辛いものになるだろう。

</P>


<H2><A NAME="SEC101" HREF="gawk_toc.html#SEC101">The <CODE>do</CODE>-<CODE>while</CODE> Statement</A></H2>

<P>
<CODE>do</CODE>ループは<CODE>while</CODE>文のバリエーションである。 <CODE>do</CODE>ループでは
<VAR>body</VAR>が一回実行され、その後<VAR>condition</VAR>が真である間<VAR>body</VAR>が繰り
返される。 <CODE>do</CODE>ループは次のような形である。

</P>

<PRE>
do
  <VAR>body</VAR>
while (<VAR>condition</VAR>)
</PRE>

<P>
開始時に<VAR>condition</VAR>が偽であったとしても、<VAR>body</VAR>が少なくとも一回
(<VAR>body</VAR>の実行によって<VAR>condition</VAR>が真にならない限りはそれきり)は
実行され、対応する<CODE>while</CODE>文とは対照的である。

</P>

<PRE>
while (<VAR>condition</VAR>)
  <VAR>body</VAR>
</PRE>

<P>
この文では<VAR>condition</VAR>が開始時に偽であった場合、<VAR>body</VAR>は実行されない。

</P>
<P>
<CODE>do</CODE>文の例を挙げよう。

</P>

<PRE>
awk '{ i = 1
       do {
          print $0
          i++
       } while (i &#60;= 10)
}'
</PRE>

<P>
この例ではレコードが入力されるごとに10回出力を行なう。これは通常は<CODE>while</CODE>
で行なうようなものであるから現実的な例ではない。しかし、それは実際の状況を
反映している。なぜなら本当に<CODE>do</CODE>文を使うことというのはまれであるからで
ある。

</P>


<H2><A NAME="SEC102" HREF="gawk_toc.html#SEC102">The <CODE>for</CODE> Statement</A></H2>
<P>
<A NAME="IDX431"></A>

</P>
<P>
<CODE>for</CODE>文はループの繰り返しを数えるのに便利である。一般的な<CODE>for</CODE>文は
次のような形をしている。

</P>

<PRE>
for (<VAR>initialization</VAR>; <VAR>condition</VAR>; <VAR>increment</VAR>)
  <VAR>body</VAR>
</PRE>

<P>
<VAR>initialization</VAR>, <VAR>condition</VAR>, <VAR>increment</VAR>
といった部分は<CODE>awk</CODE>の式を置くことができ、<VAR>body</VAR>は
<CODE>awk</CODE>の文を表わしている。

</P>
<P>
<CODE>for</CODE>文は<VAR>initialization</VAR>の実行で始まり、続いて<VAR>condition</VAR>
が真である間繰り返して<VAR>body</VAR> と <VAR>increment</VAR>が実行される。典型的
な例では、<VAR>initialization</VAR>で変数に0や1をセットするということが行なわ
れ、<VAR>increment</VAR>でその変数に1加えられる。そして<VAR>condition</VAR> では
それが繰り返しの回数を決める数と比較される。

</P>
<P>
<CODE>for</CODE>文を使った例を挙げよう。

</P>

<PRE>
awk '{ for (i = 1; i &#60;= 3; i++)
          print $i
}' inventory-shipped
</PRE>

<P>
この例では、入力レコードごとに最初の三つのフィールドを一行にひとつのフィール
ドで出力する。

</P>
<P>
<CODE>for</CODE>文の中では<VAR>body</VAR>は文であるが、<VAR>initialization</VAR>と
<VAR>condition</VAR> 、 <VAR>increment</VAR>は式である。 <VAR>initialization</VAR>部では
<CODE>x = y = 0</CODE>のような同じ初期値を全ての変数に代入する多重代入文は書くこと
ができない(しかし、<CODE>for</CODE>ループの前に、変数の初期化を追加することはで
きる)。

</P>
<P>
このことは変数のインクリメントを行なう<VAR>increment</VAR>部でも同じことである。
もしインクリメントする文を追加したいのなら、ループの終わりに文を分けて書かな
ければならない。 Cのカンマ演算子を使ったCの複合式は、そのような文脈であって
も使うことができる。が、<CODE>awk</CODE>ではサポートされていない。

</P>
<P>
ほとんどの場合、<VAR>increment</VAR>は先に挙げた例のように増減式(increment 
expression)である。しかし、常にそうである訳ではない。式であれば何でも記述す
ることができる。たとえば次の例では、2の1乗から100乗まで出力する。

</P>

<PRE>
for (i = 1; i &#60;= 100; i *= 2)
  print i
</PRE>

<P>
<CODE>for</CODE>に続くカッコの中にある三つの式はいずれも必要がなければ省略すること
ができる。したがって、<SAMP>`for (;x &#62; 0;)'</SAMP>は <SAMP>`while (x &#62; 0)'</SAMP>と
等価である。もし、<VAR>condition</VAR>が省略されたならばそれは<VAR>true</VAR>が常に真
であると解釈され、<STRONG>無限ループ</STRONG> (終了せずに繰り返しを続けるループ)とな
る。

</P>
<P>
<CODE>for</CODE>ループの大部分は、次のような<CODE>while</CODE>ループの省略形である。

</P>

<PRE>
<VAR>initialization</VAR>
while (<VAR>condition</VAR>) {
  <VAR>body</VAR>
  <VAR>increment</VAR>
}
</PRE>

<P>
唯一の例外は、ループの中で <CODE>continue</CODE>文
(セクション <A HREF="gawk_10.html#SEC104">The <CODE>continue</CODE> Statement</A>を参照) 
が使われているときである。このやり方で<CODE>for</CODE> 文を <CODE>while</CODE>に書き換え
るときはループの中の<CODE>continue</CODE>文の効果を変えることができる。

</P>
<P>
次に<CODE>for</CODE>文の別なバージョンの例を挙げよう。これは配列の添え字をすべて
繰り返す。

</P>

<PRE>
for (i in array)
    array[i] に対するなんらかの操作
</PRE>

<P>
この形式の<CODE>for</CODE>ループに関する詳しい説明は
セクション <A HREF="gawk_12.html#SEC117">Scanning All Elements of an Array</A>を参照。

</P>
<P>
<CODE>awk</CODE>言語は<CODE>while</CODE>文に加えて、<CODE>for</CODE>文を持っている。なぜなら、
<CODE>for</CODE>ループはしばしば記述したよりも少ないタイプ量でより自然な考え方であ
るからである。繰り返しの回数を数えるループはよくあるループである。
<CODE>for</CODE>を使うことによってループの内側で数えあげるよりもループの数えあげ部
を考えた方が簡単である。

</P>
<P>
次のセクションではより複雑な<CODE>for</CODE>ループの例を挙げる。

</P>



<H2><A NAME="SEC103" HREF="gawk_toc.html#SEC103">The <CODE>break</CODE> Statement</A></H2>
<P>
<A NAME="IDX432"></A>
<A NAME="IDX433"></A>

</P>
<P>
<CODE>break</CODE>文は最も内側の<CODE>for</CODE>か、<CODE>while</CODE>、または
<CODE>do</CODE>-<CODE>while</CODE>のループから脱出する。以下に挙げる例はある整数の
最も小さい約数を探し、素数であるか確認する。

</P>

<PRE>
awk '# find smallest divisor of num
     { num = $1
       for (div = 2; div*div &#60;= num; div++)
         if (num % div == 0)
           break
       if (num % div == 0)
         printf "Smallest divisor of %d is %d\n", num, div
       else
         printf "%d is prime\n", num
     }'
</PRE>

<P>
最初の<CODE>if</CODE>文で剰余が0であったとき、<CODE>awk</CODE>は即座に <CODE>for</CODE>ループ
から<STRONG>breaks out</STRONG>する。これは<CODE>awk</CODE>はループに続く文に即座に進み、処理
を続けるということである。 (これは<CODE>exit</CODE>文が、<CODE>awk</CODE>プログラムの実
行を完全に止めてしまう。ということとは異なっている
セクション <A HREF="gawk_10.html#SEC107">The <CODE>exit</CODE> Statement</A>を参照.)。

</P>
<P>
次の例は先の例と等価な別のプログラムである。これは、<CODE>for</CODE> や <CODE>while</CODE>
の条件が<CODE>if</CODE>の内側にある <CODE>break</CODE>に置き換えられるということを示して
いる。

</P>

<PRE>
awk '# ある数のもっとも小さい約数を探す
     { num = $1
       for (div = 2; ; div++) {
         if (num % div == 0) {
           printf "%d の最小の約数は %d です\n", num, div
           break
         }
         if (div*div &#62; num) {
           printf "%d は素数です\n", num
           break
         }
       }
}'
</PRE>

<P>
<A NAME="IDX434"></A>
<A NAME="IDX435"></A>
<A NAME="IDX436"></A>
<A NAME="IDX437"></A>
<A NAME="IDX438"></A>
先に述べたように、<CODE>break</CODE>文をループ本体の外側で使うことは意味がない。
しかしながら、これはドキュメント化されてはいないのだが、<CODE>awk</CODE>の伝統
的な実装においては、ループの外側で<CODE>break</CODE>が使われた場合にはそこに
<CODE>next</CODE>文が置かれていたのように動作する
(セクション <A HREF="gawk_10.html#SEC105">The <CODE>next</CODE> Statement</A>を参照)。
最近のUNIX上の<CODE>awk</CODE>では、このような使い方は許されていない。
<CODE>gawk</CODE>は<SAMP>`--traditional'</SAMP>がコマンドラインオプションで指定されたと
きのみ(セクション <A HREF="gawk_15.html#SEC135">コマンドラインオプション</A>を参照)、この動作をする。指定がなか
った場合には、これはPOSIX標準では<CODE>break</CODE>はループ本体内でのみ使うこと
が規定されているので、エラー扱いとなる(d.c.)。

</P>



<H2><A NAME="SEC104" HREF="gawk_toc.html#SEC104">The <CODE>continue</CODE> Statement</A></H2>

<P>
<A NAME="IDX439"></A>
<CODE>continue</CODE> 文は <CODE>break</CODE>と似ていて、
<CODE>for</CODE>、 <CODE>while</CODE>、<CODE>do</CODE>-<CODE>while</CODE>の中でだけ使われる。
<CODE>continue</CODE>はループ本体の残りの部分をスキップし、ループの次の
サイクルを直ぐに始めさせる。これは<CODE>break</CODE>の動作、
ループの外側にジャンプするというのとはまったく対照的である。

</P>

<P>
<CODE>for</CODE>ループ中の<CODE>continue</CODE>文は<CODE>awk</CODE>に直接ループ本体の残りの部
分をスキップさせ、<CODE>for</CODE>文の increment-expressionを実行させる。例を挙げ
よう。

</P>

<PRE>
awk 'BEGIN {
     for (x = 0; x &#60;= 20; x++) {
         if (x == 5)
             continue
         printf "%d ", x
     }
     print ""
}'
</PRE>

<P>
このプログラムは0から20のうち、5を除いたすべての数を出力する。 <CODE>x++</CODE>が
スキップされないので、<CODE>x</CODE>は5のまま止まるということはない。この
<CODE>for</CODE>ループは次に挙げる<CODE>while</CODE>ループとは対照的である。

</P>

<PRE>
awk 'BEGIN {
     x = 0
     while (x &#60;= 20) {
         if (x == 5)
             continue
         printf "%d ", x
         x++
     }
     print ""
}'
</PRE>

<P>
このプログラムは<CODE>x</CODE>が一度5になると、永久にループし続ける。

</P>
<P>
<A NAME="IDX440"></A>
<A NAME="IDX441"></A>
<A NAME="IDX442"></A>
<A NAME="IDX443"></A>
<A NAME="IDX444"></A>
先に書いた通り、<CODE>continue</CODE>文はループの外側で使っても何の意味もない。
しかしドキュメント化されてはいないが、伝統的な<CODE>awk</CODE>のインプリメンテ
ーションでは、ループの外側にある<CODE>continue</CODE>文を<CODE>next</CODE>文であるか
のように扱う (セクション <A HREF="gawk_10.html#SEC105">The <CODE>next</CODE> Statement</A>を参照)。最近 
のUNIXの<CODE>awk</CODE>はこの使い方をサポートしている。<CODE>gawk</CODE>は
<SAMP>`--traditional'</SAMP>オプションがコマンドラインで指定された場合にこれをサ
ポートす る。それ以外の場合はエラーとする。なぜなら POSIX 標準では 
<CODE>continue</CODE>はループ本体の内側で使わなければならないとされているから
である(d.c.)。

</P>


<H2><A NAME="SEC105" HREF="gawk_toc.html#SEC105">The <CODE>next</CODE> Statement</A></H2>
<P>
<A NAME="IDX445"></A>

</P>
<P>
<CODE>next</CODE>文は強制的に<CODE>awk</CODE>に対して、即座にカレントレコードの処理を中
断させ、次のレコードの処理に移させる。つまり、その先のルールはカレントレコー
ドに対して適用されないということである。同様に、その時点で適用されているルー
ルのアクション部の残りもまた実行されない。

</P>
<P>
これと対照的な効果をもたらすのが<CODE>getline</CODE>関数 
(セクション <A HREF="gawk_6.html#SEC46"><CODE>getline</CODE>を使った入力</A>を参照)である。
<CODE>getline</CODE>は<CODE>awk</CODE>に次のレコードを即座に読み込みさせるが、その後の
制御は変更しない。したがって、その時点で実行しているアクションの残りの部分は、
新しい入力レコードに対して行なわれる。

</P>
<P>
最も高いレベルでは、<CODE>awk</CODE>プログラムの実行とは入力レコードを読み、それに
対してそれぞれのルールのパターンを突きあわせるというループである。このループ
を本体にルールがある <CODE>for</CODE>ループのようなものだと考えるならば、
<CODE>next</CODE>文は <CODE>continue</CODE>文のようなものである。この暗黙のループの本体
の最後までスキップし、 increment(つまり、別のレコードを読む)を実行する。

</P>
<P>
例えば、あなたの<CODE>awk</CODE>プログラムが4つのフィールドからなるレコードに対し
てだけ働き、それ以外の入力が与えられたときに失敗したくない。というのであれば、
プログラムの先頭近くのルールで次のように書けば良い。

</P>

<PRE>
NF != 4 {
  err = sprintf("%s:%d: skipped: NF != 4\n", FILENAME, FNR)
  print err &#62; "/dev/stderr"
  next
}
</PRE>

<P>
こうすれば、このルール以降のルールに正しくないレコードが渡されることはない。
エラーメッセージはエラーメッセージがそうあるべきであるように、標準エラー出力
に出力している。セクション <A HREF="gawk_7.html#SEC66">Special File Names in <CODE>gawk</CODE></A>を参照.

</P>
<P>
<A NAME="IDX446"></A>
<A NAME="IDX447"></A>
POSIXの標準によると、<CODE>next</CODE>文が<CODE>BEGIN</CODE>ルールや<CODE>END</CODE>ルール
にあるときの動作は未定義である。<CODE>gawk</CODE>はこれをシンタックスエラーで 
あるとみなす。POSIXでは許されていても、一部の<CODE>awk</CODE>処理系では
<CODE>next</CODE>が関数本体の内側に置かれることを許していなかった
(セクション <A HREF="gawk_14.html#SEC129">ユーザー定義関数</A>を参照)。
他の<CODE>next</CODE>文の使い方と同じように、関数本体の内側にある<CODE>next</CODE>文
は、次のレコードを読み込み、プログラムの最初のルールから処理を開始する。

</P>
<P>
<CODE>next</CODE>文の実行によって入力が終端に達したら、
<CODE>END</CODE>ルールにあるコードが実行される。
セクション <A HREF="gawk_9.html#SEC93">特殊パターン<CODE>BEGIN</CODE>と<CODE>END</CODE></A>を参照.

</P>
<P>
<A NAME="IDX448"></A>
<STRONG>警告:</STRONG> 幾つかの<CODE>awk</CODE>処理系には、ユーザー定義関数の中で
<CODE>next</CODE>文を使うと実行時エラーを生成するものがある
(セクション <A HREF="gawk_14.html#SEC129">ユーザー定義関数</A>を参照)。
<CODE>gawk</CODE>にはこのような問題はない。

</P>


<H2><A NAME="SEC106" HREF="gawk_toc.html#SEC106">The <CODE>nextfile</CODE> Statement</A></H2>
<P>
<A NAME="IDX449"></A>
<A NAME="IDX450"></A>

</P>
<P>
<CODE>gawk</CODE>は<CODE>next</CODE>文に似た<CODE>nextfile</CODE>文を提供している。これは、
<CODE>next</CODE>が行っているようなカレントレコードの処理を放棄するものではな 
く、<CODE>gawk</CODE>に対してカレントデータファイルの処理をやめさせるものであ 
る。

</P>
<P>
<CODE>nextfile</CODE>文の実行によって、<CODE>FILENAME</CODE>の内容はコマンドラインの次
のファイルの名前にアップデートされ、<CODE>FNR</CODE>は1にリセットされてプログラム
の最初のルールから処理が開始される。セクション <A HREF="gawk_11.html#SEC108">組み込み変数</A>を参照.

</P>
<P>
<CODE>nextfile</CODE>文は<CODE>gawk</CODE>での拡張機能である。この機能は（少なくとも現
在のところ）他の<CODE>awk</CODE>処理系では使用できない。 
<CODE>nextfile</CODE>をシミュレートするのに使えるユーザー定義関数は
セクション <A HREF="gawk_16.html#SEC143">Implementing <CODE>nextfile</CODE> as a Function</A>を参照,

</P>
<P>
<CODE>nextfile</CODE>文は多くのデータファイルを処理する状況で、データの性質によっ
て、ファイル中のレコードの全てを処理する、ということを望まない場合に便利であ
る。次のデータファイルに移る手段として、希望しないレコードをスキャンし続けな
ければならないだろう(先程書いたように)。 <CODE>next file</CODE>文はより能率的にそ
れを実行する。

</P>
<P>
<A NAME="IDX451"></A>
<STRONG>警告:</STRONG>3.0以前のバージョンの<CODE>gawk</CODE>では、
<CODE>nextfile</CODE>文には二つの単語(<SAMP>`next file'</SAMP>)を使っていた。
これは3.0で一つの単語に変更された。それは、
<SAMP>`file'</SAMP>の取り扱いが一貫性のないものであったからだ。
<SAMP>`file'</SAMP>が<CODE>next</CODE>の後に現れた場合、それはキーワードとなる
しかし、それ以外の場合には通常の識別子になるのだ。
古い使用法もまだ受け付けられるが、<CODE>gawk</CODE>は
警告メッセージを出力するし、<CODE>next file</CODE>は
将来の<CODE>gawk</CODE>のバージョンではサポートされなくなるだろう。

</P>


<H2><A NAME="SEC107" HREF="gawk_toc.html#SEC107">The <CODE>exit</CODE> Statement</A></H2>

<P>
<A NAME="IDX452"></A>
<CODE>exit</CODE>文は<CODE>awk</CODE>に対して即座に現在処理しているルールの実行をやめさ
せ、入力の処理もやめさせる。残った入力は無視される。

</P>

<PRE>
exit [<VAR>return code</VAR>]
</PRE>

<P>
<CODE>exit</CODE>文が<CODE>BEGIN</CODE>ルールで実行された場合、プログラムは停止し、すべ
ての処理も即座に停止して、入力レコードは読まれない。しかし、<CODE>END</CODE>ルール
がある場合にはそれが実行される。
(セクション <A HREF="gawk_9.html#SEC93">特殊パターン<CODE>BEGIN</CODE>と<CODE>END</CODE></A>を参照).

</P>
<P>
<CODE>exit</CODE> が <CODE>END</CODE>ルールで使われた場合には
プログラムは即座に停止する。

</P>
<P>
<CODE>BEGIN</CODE> ルールでも  <CODE>END</CODE>ルールでもないところで
<CODE>exit</CODE>文を使った場合、それ以後のルールの実行は行なわれないが、
<CODE>END</CODE>ルールだけは（記述されていれば）実行される。

</P>
<P>
もし、このような場合に<CODE>END</CODE>ルールを実行したくないというのであれば、 
<CODE>exit</CODE>文の前である変数に0以外の値をセットし、
その変数を <CODE>END</CODE>ルールの中でチェックすれば良い。
この例は
セクション <A HREF="gawk_16.html#SEC144">Assertions</A>を参照.。

</P>
<P>
<A NAME="IDX453"></A>
<CODE>exit</CODE>に引数を与えた場合、その値は<CODE>awk</CODE>を実行している
プロセスの終了ステータスの値として使われる。
引数がない場合には、<CODE>exit</CODE>は0(成功)を返す。
引数つきの<CODE>ext</CODE>文を最初に実行し、その後で引数なしの
<CODE>exit</CODE>文を実行すると、その前に使った引数が
終了ステータスとして使われる(d.c.)。

</P>
<P>
例えば、対処できないエラー状態になったときに、それを報告するとしよう。
一般的にはプログラムはこれを0以外の終了コードによって報告する。
<CODE>awk</CODE>プログラムはこれを、<CODE>exit</CODE>文を0以外の引数付きで
使うことによって実現できる。例を挙げよう。

</P>

<PRE>
BEGIN {
       if (("date" | getline date_now) &#60;= 0) {
         print "Can't get system date" &#62; "/dev/stderr"
         exit 1
       }
       print "current date is", date_now
       close("date")
}
</PRE>

<HR>
移動先 <A HREF="gawk_1.html">先頭</A>, <A HREF="gawk_9.html">前</A>, <A HREF="gawk_11.html">次</A>, <A HREF="gawk_25.html">末尾</A> セクション, <A HREF="gawk_toc.html">目次</A>.
</BODY>
</HTML>
