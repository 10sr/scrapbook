<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0 Strict Level 2//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html;charset=iso-2022-jp">
<!-- This HTML file has been created by texi2html 1.47
     from gawk.tex on 10 文月 1999 -->

<TITLE>The GNU Awk User's Guide - 入力ファイルの読み込み</TITLE>
</HEAD>
<BODY>
移動先 <A HREF="gawk_1.html">先頭</A>, <A HREF="gawk_5.html">前</A>, <A HREF="gawk_7.html">次</A>, <A HREF="gawk_25.html">末尾</A> セクション, <A HREF="gawk_toc.html">目次</A>.
<HR>


<H1><A NAME="SEC33" HREF="gawk_toc.html#SEC33">入力ファイルの読み込み</A></H1>

<P>
<A NAME="IDX162"></A>
<A NAME="IDX163"></A>
<A NAME="IDX164"></A>
<A NAME="IDX165"></A>
典型的な<CODE>awk</CODE>プログラムでは、すべての入力は標準入力(デフォルトでは 
キーボードだが、ほとんどの場合は他のコマンドからのパイプ)かコマンドライ 
ンで指定した名前のファイルのどちらかから読み込まれる。入力ファイルを指定
している場合、<CODE>awk</CODE>は指定した順番に従ってすべてのファイルからデータ
の読み込みを行う。ある時点で処理している入力ファイルのファイル名は組込み
変数<CODE>FILENAME</CODE>(セクション <A HREF="gawk_11.html#SEC108">組み込み変数</A>を参照)から得ることができる。

</P>
<P>
入力は<STRONG>レコード</STRONG>と呼ばれる単位で読み込まれ、プログラムに記述されたル
ールに従い、一度に一つのレコードを処理する。デフォルトでは各レコードはひ
とつの行である。各レコードは<STRONG>フィールド</STRONG>と呼ばれる塊に自動的に分割さ
れる。これはあるレコードの一部分について作業を行うプログラムに便利である。

</P>
<P>
まれに特別な場合に、<CODE>getline</CODE>コマンドを使う必要にせまられることがあ
るだろう。<CODE>getline</CODE>コマンドは任意の数のファイルから陽に入力を行うこ
とを可能にし、コマンドライン上で名前を指定しなくてもファイルから読み込み
ができるので重宝する。
(セクション <A HREF="gawk_6.html#SEC46"><CODE>getline</CODE>を使った入力</A>を参照).

</P>



<H2><A NAME="SEC34" HREF="gawk_toc.html#SEC34">入力をレコードへと分割をするやりかた</A></H2>

<P>
<A NAME="IDX166"></A>
<A NAME="IDX167"></A>
<A NAME="IDX168"></A>
<A NAME="IDX169"></A>
<CODE>awk</CODE>ユーティリティは<CODE>awk</CODE>プログラムに対する入力をレコードとフ
ィールドに分割する。レコードは<STRONG>レコードセパレータ</STRONG>と呼ばれるキャラク
タによって分割される。デフォルトでは、レコードセパレータは改行キャラクタ
である。これはデフォルトではレコードが単一の行であるからである。組込み変
数の<CODE>RS</CODE>に値をセットすることによって、レコードセパレータを別のキャ 
ラクタにすることができる。

</P>
<P>
他の変数と同じ様に、代入演算子<SAMP>`='</SAMP>
(セクション <A HREF="gawk_8.html#SEC79">代入式</A>を参照)を使って<CODE>awk</CODE>プロ
グラム中で<CODE>RS</CODE>の値を変更することも可能である。

</P>
<P>
新しいレコードセパレータのキャラクタは、それが文字列定数であることを示す
ために引用符で括ったほうがよい。ほとんどの場合、これを行うための正しいタ
イミングは実行開始時、入力がなんらかの処理を行う前、つまり、最初のレコー
ドがレコードセパレータを使って読み込まれる前である。これを行うために   
code{BEGIN}スペシャルパターを使用する
(セクション <A HREF="gawk_9.html#SEC93">特殊パターン<CODE>BEGIN</CODE>と<CODE>END</CODE></A>を参照)。
例えば、

</P>

<PRE>
awk 'BEGIN { RS = "/" } ; { print $0 }' BBS-list
</PRE>

<P>
この例では、入力を行う前に<CODE>RS</CODE>に値を<CODE>"/"</CODE>に変更している。
これはスラッシュが先頭にある文字列であり、結果として
レコードはスラッシュで分割される。その後で入力ファイルが読み込まれ、
<CODE>awk</CODE>プログラムの二番目のルール(パターンのないアクション)
によって各レコードが出力される。各<CODE>print</CODE>文はその出力の
最後に改行を追加するので、この<CODE>awk</CODE>プログラムは
入力のスラッシュを改行に変換してコピーする。次にこのプログラムを
<TT>`BBS-list'</TT>に対して実行したときの結果を示す。

</P>

<PRE>
$ awk 'BEGIN { RS = "/" } ; { print $0 }' BBS-list
-| aardvark     555-5553     1200
-| 300          B
-| alpo-net     555-3412     2400
-| 1200
-| 300     A
-| barfly       555-7685     1200
-| 300          A
-| bites        555-1675     2400
-| 1200
-| 300     A
-| camelot      555-0542     300               C
-| core         555-2912     1200
-| 300          C
-| fooey        555-1234     2400
-| 1200
-| 300     B
-| foot         555-6699     1200
-| 300          B
-| macfoo       555-6480     1200
-| 300          A
-| sdace        555-3430     2400
-| 1200
-| 300     A
-| sabafoo      555-2127     1200
-| 300          C
-|
</PRE>

<P>
<SAMP>`camelot'</SAMP>BBSのエントリが分割されていないことに注意。
元のデータファイル
(セクション <A HREF="gawk_2.html#SEC9">例で使用するデータファイル</A>を参照)、
では、このような行だった。

</P>

<PRE>
camelot      555-0542     300               C
</PRE>

<P>
そこにはボーレートが一つだけしかなく、スラッシュがレコード中にない。

</P>
<P>
レコードセパレータを変更するもう一つのやり方は、コマンドライン上で
変数代入の機能を使うことである。
(セクション <A HREF="gawk_15.html#SEC136">Other Command Line Arguments</A>を参照).

</P>

<PRE>
awk '{ print $0 }' RS="/" BBS-list
</PRE>

<P>
これは<TT>`BBS-list'</TT>を処理する前に<CODE>RS</CODE>に<SAMP>`/'</SAMP>を
セットする。

</P>
<P>
<SAMP>`/'</SAMP>のような一般的でないキャラクタをレコードセパレータに
つかうことは、ほとんどすべての場合に正しい結果を生じる。
しかしながら、以下の様な(極端な)パイプラインでは、
意外にも<SAMP>`1'</SAMP>が出力される。
そこには改行からなる一つのフィールドがある。
組込み変数<CODE>NF</CODE>の値はカレントレコードのフィールドの数である。

</P>

<PRE>
$ echo | awk 'BEGIN { RS = "a" } ; { print NF }'
-| 1
</PRE>

<P>
<A NAME="IDX170"></A>
入力ファイルの終端に達すると、
そのファイルの最後のキャラクタが<CODE>RS</CODE>にあるキャラクタで
なくてもカレント入力レコードを終端する(d.c.)。

</P>
<P>
<A NAME="IDX171"></A>
空文字列<CODE>""</CODE>(キャラクタが何もない文字列)は、
<CODE>RS</CODE>の値としては特別な意味を持っている。
それは、レコードを一行以上の空行で区切るということである。
詳しくは
セクション <A HREF="gawk_6.html#SEC45">複数行レコード</A>を参照.。

</P>
<P>
<CODE>awk</CODE>の実行中に<CODE>RS</CODE>の値を変更した場合、
その新しい値は後続のレコードの区切りに使用されるが、
現在処理されているレコード(と既に処理されたレコード)
にはなんの影響も及ぼさない。

</P>
<P>
<A NAME="IDX172"></A>
<A NAME="IDX173"></A>
<A NAME="IDX174"></A>
<A NAME="IDX175"></A>
レコードの区切りが終了した後で、<CODE>awk</CODE>は
<CODE>RS</CODE>にマッチした入力中のテキストを
<CODE>RT</CODE>という変数にセットする。

</P>
<P>
<A NAME="IDX176"></A>
<CODE>RS</CODE>の値は一文字に限定されるものではなく、任意の正規表現
(セクション <A HREF="gawk_5.html#SEC25">正規表現</A>を参照)を使用することができる。
一般的には各レコードの終端にはその正規表現にマッチした文字列が続いており、
次のレコードはマッチした文字列の終端の次から始まる。この一般的なルールは
通常の<CODE>RS</CODE>が改行だけからなっているようなときにはうまく働く。レコー 
ドは次のマッチする文字列の先頭(入力の次の改行)で終わり、続くレコードはこ
の文字列のすぐ後(続く行の先頭のキャラクタ)から始まる。改行は<CODE>RS</CODE>に 
マッチするので、いずれのレコードの一部分にもならない。

</P>
<P>
<CODE>RS</CODE>が単一のキャラクタであったとき、<CODE>RT</CODE>はそれと同じキャラクタ
一文字になる。しかし、<CODE>RS</CODE>が正規表現であるとき、<CODE>RT</CODE>はもっと便
利になる。つまり、実際に正規表現にマッチした入力テキストが格納されるので
ある。

</P>
<P>
次に挙げる例はこれらの機能を両方とも説明している。<CODE>RS</CODE>は改行にも、 
(前後に連続した空白が付いてもよい)一つ以上の連続した大文字にもマッチする
正規表現がセットされている(セクション <A HREF="gawk_5.html#SEC25">正規表現</A>を参照)。

</P>

<PRE>
$ echo record 1 AAAA record 2 BBBB record 3 |
&#62; gawk 'BEGIN { RS = "\n|( *[[:upper:]]+ *)" }
&#62;             { print "Record =", $0, "and RT =", RT }'
-| Record = record 1 and RT =  AAAA 
-| Record = record 2 and RT =  BBBB 
-| Record = record 3 and RT = 
-|
</PRE>

<P>
出力の最後の行は余計な空白行がある。
これは、<CODE>RT</CODE>の値が改行で、さらに<CODE>print</CODE>文が
改行を最後につけているからである。

</P>
<P>
<CODE>RS</CODE>に正規表現を設定したり、<CODE>RT</CODE>を使った便利な
サンプルについてはセクション <A HREF="gawk_17.html#SEC172">シンプルなストリームエディター</A>を参照.

</P>
<P>
<A NAME="IDX177"></A>
<CODE>RS</CODE> はレコードの終端を決めるために用いられる。
<CODE>RS</CODE>を正規表現として使用することと、<CODE>RT</CODE>変数は
<CODE>gawk</CODE>における拡張である。これらは互換モードでは使用する
ことはできない(セクション <A HREF="gawk_15.html#SEC135">コマンドラインオプション</A>を参照).。
互換モードでは、<CODE>RS</CODE>の先頭のキャラクタのみがレコードの
終端を決定するのに使われる。

</P>
<P>
<A NAME="IDX178"></A>
<A NAME="IDX179"></A>
<A NAME="IDX180"></A>
<CODE>awk</CODE>は現在の入力ファイルから読み込んだレコードの数を記憶している。
その値は<CODE>FNR</CODE>という名前の組み込み変数に記録されている。この
変数は新しいファイルを読み込み始めたときに0にリセットされる。
別の組み込み変数<CODE>NR</CODE>は、すべてのデータファイルから読み込んだレコードの
数を記録している。この変数は0から始まるが、自動的に0にリセットされる
ことはない。

</P>


<H2><A NAME="SEC35" HREF="gawk_toc.html#SEC35">フィールドの検査</A></H2>

<P>
<A NAME="IDX181"></A>
<A NAME="IDX182"></A>
<A NAME="IDX183"></A>
<CODE>awk</CODE>が入力レコードを読み込んだとき、そのレコードは自動的に
インタープリタによって解析され、<STRONG>フィールド</STRONG>と呼ばれる塊に
分割される。デフォルトではフィールドの分割は行の中にある
単語のように、空白(whitespace)によって行われる。
<CODE>awk</CODE>での空白は、スペースかタブ、あるいは改行の
一つ以上の連なりである<A NAME="FOOT6" HREF="gawk_foot.html#FOOT6">(6)</A>。
ほかの言語では空白とみなされるような改行やフォームフィードなどの
キャラクタは、<CODE>awk</CODE>の場合は空白としては<STRONG>みなされない</STRONG>。

</P>
<P>
フィールドの目的は、レコードのこういった塊を参照するのに
便利なようにするためであり、フィールドを使わなければならない
というものではない。望むならレコード全体を処理することもできる。
しかし、フィールドはパワフルな<CODE>awk</CODE>プログラムを簡単にするのである。

</P>
<P>
<A NAME="IDX184"></A>
<A NAME="IDX185"></A>
<CODE>awk</CODE>プログラム中でフィールドを参照するには、ドル記号<SAMP>`$'</SAMP>に
続けて参照したいフィールドの番号を続けることによっておこなう。
したがって、<CODE>$1</CODE>は最初のフィールドを、<CODE>$2</CODE>は二番目のフィールドを
参照する。例えば次のような行が入力されたとすると、

</P>

<PRE>
This seems like a pretty nice example.
</PRE>

<P>
この例の場合、最初のフィールドである<CODE>$1</CODE>の内容は<SAMP>`This'</SAMP>である。
二番目のフィールド、<CODE>$2</CODE>の内容は<SAMP>`seems'</SAMP>というようになる。
最後のフィールド<CODE>$7</CODE>が<SAMP>`example.'</SAMP>であることに注意して欲しい。
これは、<SAMP>`e'</SAMP> と <SAMP>`.'</SAMP>の間にスペースがないためで、ピリオドは
七番目のフィールドの一部であるとみなされているのである。

</P>
<P>
<A NAME="IDX186"></A>
<A NAME="IDX187"></A>
<CODE>NF</CODE>はカレントレコードにあるフィールドの数を保持する組み込み変数
である。<CODE>awk</CODE>はレコードの読み込みのたびに<CODE>NF</CODE>の値を自動的に
更新する。

</P>
<P>
フィールドが幾つあるかにかかわらず、あるレコードの最後のフィールドは
<CODE>$NF</CODE>で表わすことができる。だから、先程の例でいうと、<CODE>$NF</CODE>は
<CODE>$7</CODE>と同じことであり、内容は<SAMP>`example.'</SAMP>になる。
これが動作するわけは後述する
(セクション <A HREF="gawk_6.html#SEC36">定数でないフィールド番号</A>を参照)。
レコード中にフィールドが七個しかないときに
<CODE>$8</CODE>のように最後の要素を越えて参照しようとしたときには、
空の文字列が返ってくる。

</P>
<P>
<CODE>$0</CODE>は"0番目"のフィールドを参照するように見えるが、
これは特別なケースで入力レコード全体を表わす。<CODE>$0</CODE>は
フィールドを気にしたくないときに使用する。

</P>
<P>
さらに幾つかの例を挙げよう。

</P>

<PRE>
$ awk '$1 ~ /foo/ { print $0 }' BBS-list
-| fooey        555-1234     2400/1200/300     B
-| foot         555-6699     1200/300          B
-| macfoo       555-6480     1200/300          A
-| sabafoo      555-2127     1200/300          C
</PRE>

<P>
この例では、<TT>`BBS-list'</TT>というファイル中のレコードで、
レコードの第一フィールドに<SAMP>`foo'</SAMP>という文字列を含んでいる
ものを出力している。
<SAMP>`~'</SAMP>という演算子は<STRONG>マッチング演算子</STRONG>(matching operator)
(セクション <A HREF="gawk_5.html#SEC26">正規表現の使い方</A>を参照)と
呼ばれ、ある文字列(ここではフィールド<CODE>$1</CODE>)と与えられた
正規表現とがマッチするかを検査する。

</P>
<P>
一方次の例は、<STRONG>レコード全体</STRONG>から<SAMP>`foo'</SAMP>を探して、
それが見つかった入力レコードの第一フィールドと最終フィールドを
出力する。

</P>

<PRE>
$ awk '/foo/ { print $1, $NF }' BBS-list
-| fooey B
-| foot B
-| macfoo A
-| sabafoo C
</PRE>



<H2><A NAME="SEC36" HREF="gawk_toc.html#SEC36">定数でないフィールド番号</A></H2>

<P>
フィールドの番号は定数である必要はない。
あるフィールドを参照するために、<CODE>awk</CODE>言語での
任意の式を$samp{$}の後で使うことができる。
その式の値はフィールド番号として扱われる。このとき式が数値ではなく
文字列であった場合、その式の値は数値へと変換される。
例を挙げよう。

</P>

<PRE>
awk '{ print $NR }'
</PRE>

<P>
<CODE>NR</CODE>はそれまでに読み込んだレコードの数だということを思い出そう。
一番目のレコードでは1、二番目では2…というようになる。
したがってこの例は、一番目のレコードの一番目のフィールド、
二番目のレコードの二番目のフィール…と出力していく。
二十番目のレコードでは二十番目のフィールドが出力されることに
なるが、ほとんどの場合はレコードには20未満のフィールドしかないから、
空白行が出力されるだろう。

</P>
<P>
もう一つフィールド番号として式を使った例を挙げる。

</P>

<PRE>
awk '{ print $(2*2) }' BBS-list
</PRE>

<P>
<CODE>awk</CODE> は<CODE>(2*2)</CODE>という式を評価し、それからその値を出力すべきフィー
ルドの番号として使用する。<SAMP>`*'</SAMP>は乗算を表すので、<CODE>2*2</CODE> という式を評
価すると4となる。括弧は<SAMP>`$'</SAMP>のオペレーションより先に掛け算を行わせるため
である。フィールド番号を指定する式で二項演算子を使うときは常にこのようにす
る必要がある。この例では<TT>`BBS-list'</TT>というファイル中の全ての行の、運営時
間(4番目のフィールド)を出力する
(<CODE>awk</CODE>で使える演算子の全ては
セクション <A HREF="gawk_8.html#SEC86">Operator Precedence (How Operators Nest)</A>を参照.
に一覧がある)。

</P>
<P>
フィールド番号が0になるような式を与えると、その結果はレコード全体となる。だ
から、 <CODE>$(2-2)</CODE>の値は<CODE>$0</CODE>と同じである。負の数によるフィールド番号
の指定は許されおらず、もしそういったフィールドを参照しようとすると、
通常は<CODE>awk</CODE>プログラムの実行が中断される(POSIXの標準では、負のフィールド
番号を参照したときの
動作は定義されていない。<CODE>gawk</CODE>ではこれを通知して、
プログラムを終了する。他の<CODE>awk</CODE>処理系では
違った動作をするかもしれない)。

</P>
<P>
セクション <A HREF="gawk_6.html#SEC35">フィールドの検査</A>を参照で述べられているように、
カレントレコードのフィールド数は組込み変数の
<CODE>NF</CODE>(セクション <A HREF="gawk_11.html#SEC108">組み込み変数</A>を参照)に格納されている。
<CODE>$NF</CODE>という式は特別な機能ではなく、<CODE>NF</CODE>を
評価して、その値をフィールド番号として使った結果である。

</P>


<H2><A NAME="SEC37" HREF="gawk_toc.html#SEC37">フィールドの内容を変更する</A></H2>

<P>
<A NAME="IDX188"></A>
<A NAME="IDX189"></A>
<CODE>awk</CODE>プログラムの中でフィールドの構成を変更することが
でき、それによって<CODE>awk</CODE>はカレント入力レコードが
変更されたと認識する(実際の入力には影響ない。<CODE>awk</CODE>は<STRONG>決して</STRONG>
入力ファイルを変更しない)。

</P>
<P>
サンプルとその出力を例示する。

</P>

<PRE>
$ awk '{ $3 = $2 - 10; print $2, $3 }' inventory-shipped
-| 13 3
-| 15 5
-| 15 5
...
</PRE>

<P>
<SAMP>`-'</SAMP>記号は減算の記号であるので、このプログラムは
三番目のフィールド<CODE>$3</CODE>に<SAMP>`$2 - 10'</SAMP>、つまり二番目のフィールド
の値から10を引いた値を
セットする(セクション <A HREF="gawk_8.html#SEC77">Arithmetic Operators</A>を参照.)。
それから二番目のフィールドと新しい三番目のフィールドが出力される。

</P>
<P>
これがきちんと動作するには、フィールド<CODE>$2</CODE>のテキストは
数として意味のあるものでなければならない。
(フィールドの)文字列は算術演算を行うために数値に変換される。
引き算の結果(の数値)は文字列に変換されて、第三フィールドになる。
セクション <A HREF="gawk_8.html#SEC76">Conversion of Strings and Numbers</A>を参照.

</P>
<P>
あるフィールドの値を変更した(<CODE>awk</CODE>がそう認識した)とき、
入力レコードのテキストは新しいフィールドが古いフィールドの
ところにあるように再演算が行われる。
そのため、<CODE>$0</CODE>がフィールドの変更を反映して変化するのである。
したがって、次のプログラムは、
入力ファイルのデータの各行の第二フィールドが
入力ファイルにあったものから10を引いたものに置き換えられた      
結果を出力するのである。

</P>

<PRE>
$ awk '{ $2 = $2 - 10; print $0 }' inventory-shipped
-| Jan 3 25 15 115
-| Feb 5 32 24 226
-| Mar 5 24 34 228
...
</PRE>

<P>
最大のフィールド番号より大きい、存在しないフィールドに対する代入も可能である。
例を挙げよう

</P>


<PRE>
$ awk '{ $6 = ($5 + $4 + $3 + $2)
&#62;        print $6 }' inventory-shipped
-| 168
-| 297
-| 301
...
</PRE>

<P>
ここでは<CODE>$6</CODE>が新たに作り出されて、 <CODE>$2</CODE>, <CODE>$3</CODE>, <CODE>$4</CODE>,
<CODE>$5</CODE>の各フィールドの合計が格納される。 The <SAMP>`+'</SAMP>は足し算の記号であ
る。 <TT>`inventory-shipped'</TT>というファイルを使って各月ごとの積込量の合計を
<CODE>$6</CODE>に設定する。

</P>
<P>
新しいフィールドを作成すると、<CODE>awk</CODE>内部にあるカレントレコードのコピー
が変更される。したがって、フィールドを付け加えた後で<SAMP>`print $0'</SAMP>を出力す
るとその結果には新しいフィールドが含まれている。

</P>
<P>
この再計算の効果と再計算を行う機能についての説明はまだされていない。フィー
ルドの区切りを指定する出力フィールド指定子<CODE>OFS</CODE>や <CODE>NF</CODE> （フィール
ドの数セクション <A HREF="gawk_6.html#SEC35">フィールドの検査</A>を参照）についての説明もまだである。例
えば、<CODE>NF</CODE>の値は新たに作り出されたフィールドのフィールド番号の最大のも
のがセットされる。

</P>
<P>
しかし気をつけなければならないのは、範囲外のフィールドにたいする
<STRONG>参照</STRONG>は<CODE>$0</CODE>の値も<CODE>NF</CODE>の値も<STRONG>変更しない</STRONG>
ということである。
範囲外のフィールドに対する参照は単に空文字列を生成するだけである。
例を挙げよう。

</P>

<PRE>
if ($(NF+1) != "")
    print "can't happen"
else
    print "everything is normal"
</PRE>

<P>
これは<SAMP>`everything is normal'</SAMP>が出力されるはずだ。
なぜなら、<CODE>NF+1</CODE>は範囲の外にあるからである
(<CODE>awk</CODE>の<CODE>if-else</CODE>文についての詳しい情報は
セクション <A HREF="gawk_10.html#SEC99">The <CODE>if</CODE>-<CODE>else</CODE> Statement</A>を参照。
<SAMP>`!='</SAMP>演算子の詳しい情報は
セクション <A HREF="gawk_8.html#SEC82">Variable Typing and Comparison Expressions</A>を参照.)。

</P>
<P>
既に存在するフィールドに何かを代入することによって
<CODE>$0</CODE>の値は変化するが、たとえフィールドに空文字列を代入したとしても
<CODE>NF</CODE>の値は変化しないということは重要である。
例えば、

</P>

<PRE>
$ echo a b c d | awk '{ OFS = ":"; $2 = ""
&#62;                       print $0; print NF }'
-| a::c:d
-| 4
</PRE>

<P>
フィールドは空の値を持って存在しつづけている。
それは、二つのコロンが連続していることで確認できる。

</P>
<P>
次の例は新しいフィールドを作ったときに何が起こるのかと
いうことを見せている。

</P>

<PRE>
$ echo a b c d | awk '{ OFS = ":"; $2 = ""; $6 = "new"
&#62;                       print $0; print NF }'
-| a::c:d::new
-| 6
</PRE>

<P>
<CODE>$5</CODE>が間に入って、空の値で作成されていて
(二つめの並んだコロンによって判断できる)、
<CODE>NF</CODE>の値が6に更新されている。

</P>
<P>
結局のところ、<CODE>NF</CODE>の値を減じることによって新たな<CODE>NF</CODE>の
値より後ろのフィールドの値は失われることとなり、<CODE>$0</CODE>の再計
算が行なわれる。以下はその例である。

</P>

<PRE>
$ echo a b c d e f | ../gawk '{ print "NF =", NF; 
&#62;                               NF = 3; print $0 }'
-| NF = 6
-| a b c
</PRE>



<H2><A NAME="SEC38" HREF="gawk_toc.html#SEC38">フィールドの分割方法の指定</A></H2>

<P>
このセクションは長く、<CODE>awk</CODE>における基本的な操作の一つを
説明する。

</P>



<H3><A NAME="SEC39" HREF="gawk_toc.html#SEC39">フィールド分割の基礎</A></H3>
<P>
<A NAME="IDX190"></A>
<A NAME="IDX191"></A>
<A NAME="IDX192"></A>

</P>
<P>
<STRONG>フィールドセパレータ</STRONG>はある一文字か、あるいは正規表現であり、
<CODE>awk</CODE>が入力レコードをどのようにフィールドに分割するかを
制御する。<CODE>awk</CODE>は入力レコード中に
そのセパレータにマッチするキャラクタの並びがないか
検索する。フィールドそのものはマッチしたものの間にあるテキストである

</P>
<P>
次に挙げる例では出力中のスペースを"*"という
シンボルを使って表わしている。

</P>
<P>
フィールドセパレータが<SAMP>`oo'</SAMP>で、以下の行があったとすると

</P>

<PRE>
moo goo gai pan
</PRE>

<P>
これは三つのフィールド
<SAMP>`m'</SAMP>、 <SAMP>`*g'</SAMP>、<SAMP>`*gai*pan'</SAMP>
に分割される。
第二フィールドと第三フィールドの先頭にあるスペースに注意。

</P>
<P>
<A NAME="IDX193"></A>
フィールドセパレータは組込み変数の<CODE>FS</CODE>で示される。
シェルプログラマは注意すること!
<CODE>awk</CODE>は
(Bourne シェル、<CODE>sh</CODE>やGNU Bourne-Again Shell、Bashのような)
POSIX互換のシェルが使っている<CODE>IFS</CODE>という名前の変数は
<STRONG>使わない</STRONG>。

</P>
<P>
<CODE>awk</CODE>プログラム中で代入演算子<SAMP>`='</SAMP>
(セクション <A HREF="gawk_8.html#SEC79">代入式</A>を参照)
を使って<CODE>FS</CODE>の値を変更することができる。

</P>
<P>
ほとんどの場合、これ(<CODE>FS</CODE>の値を変更すること)を行うのに正しいタイミ 
ングは実行の開始時、入力が処理される以前である。これは一番最初のレコード
が適切なセパレータで読み込みが行われるからである。このタイミングで変更を
行うためには<CODE>BEGIN</CODE>スペシャルパターンを使う
(セクション <A HREF="gawk_9.html#SEC93">特殊パターン<CODE>BEGIN</CODE>と<CODE>END</CODE></A>を参照)。
例えば、次の例では<CODE>FS</CODE>の値を<CODE>","</CODE>という文字列に設定している。

</P>

<PRE>
awk 'BEGIN { FS = "," } ; { print $2 }'
</PRE>

<P>
Given the input line,
入力として次のものを与える。

</P>

<PRE>
John Q. Smith, 29 Oak St., Walamazoo, MI 42139
</PRE>

<P>
先の<CODE>awk</CODE>プログラムは
<SAMP>`*29*Oak*St.'</SAMP>
という文字列をレコードから取り出し、出力する。

</P>
<P>
<A NAME="IDX194"></A>
<A NAME="IDX195"></A>
ときとして、セパレートキャラクタを含んではいるがそれを分割したくはないとい
うデータを扱いたいときがあるかもしれない。例えば、<SAMP>`John Q. Smith, LXIX'</SAMP>
の様にタイトルがついているとか、拡張子がくっついているようなデータを扱うよう
な場合である。入力データの中に次のような名前があったとすると、

</P>

<PRE>
John Q. Smith, LXIX, 29 Oak St., Walamazoo, MI 42139
</PRE>

<P>
先のサンプルプログラムは<SAMP>` 29 Oak St.'</SAMP>ではなく、<SAMP>`  LXIX'</SAMP>を取り出
す。もしプログラムが住所を出力すると期待していたならば、その結果に驚かされ
るかもしれない。だから、この様な問題を避けるためにデータのレイアウトと、セパ
レータとなるキャラクタは慎重に選択せねばならない。

</P>
<P>
既に知っているように、通常は
フィールドは一つの空白ではなく空白の並び(スペースかタブか改行)で区切られる。
フィールドセパレータのデフォルトの値は
<CODE>" "</CODE>という文字列であるが、もしこの値を普通通り使ったとしたら、二つ
の空白からなるような行は空白は二つのフィールドセパレータとして扱われ、結果と
して空のフィールドを作りだすのだろうか? 実際には以下の理由によってこのような
ことは行われない。<CODE>FS</CODE>の値が一つの空白であった場合には特殊な場合として、
フィールドの分割のルールをデフォルトと同じ様にする。

</P>
<P>
<CODE>FS</CODE>の値が他のキャラクタが一文字、例えば<CODE>","</CODE>の様な場合にはキャラ
クタは二つのフィールドを分割する様な結果となる。二つの連続したキャラクタは
空のフィールドを分割する。もし、行の先頭や末尾に（区切りの）キャラクタがあっ
た場合には空のフィールドがあるように区切る。スペースはこのルールに従わない
ただ一つのキャラクタである。

</P>


<H3><A NAME="SEC40" HREF="gawk_toc.html#SEC40">フィールド分割に正規表現を使う</A></H3>

<P>
The previous
先の
subsection
サブセクション
で<CODE>FS</CODE>の値として
単一のキャラクタや単純な文字列を使用した。
より一般的には、<CODE>FS</CODE>の値は
なんらかの正規表現であってよい。
この場合、レコード中でそれにマッチ正規表現が
フィールドの分割をする。
例えば

</P>

<PRE>
FS = ", \t"
</PRE>

<P>
このような代入は
for the complete list of similar escape sequences.)
カンマ、スペース、タブが後ろに続いている領域が
フィールドになる
(<SAMP>`\t'</SAMP>は<STRONG>エスケープシーケンス</STRONG>であり、これは
タブを表わしている。同じようなエスケープシーケンスの
完全なリストはセクション <A HREF="gawk_5.html#SEC27">エスケープシーケンス</A>を参照にある)。

</P>
<P>
正規表現のあまり重要でない例として、
先の例のカンマのように、一つのスペースでフィールド分割を
行いたいという状況を考えよう。
これは、<CODE>FS</CODE>に<CODE>"[ ]"</CODE> (左ブラケット
スペース、右ブラケット)をセットすることでできる。
この正規表現は一つのスペースにマッチし、他のものには
マッチしない(セクション <A HREF="gawk_5.html#SEC25">正規表現</A>を参照)。

</P>

<P>
<SAMP>`FS = " "'</SAMP>(一つのスペース)と、<SAMP>`FS = "[ \t\n]+"'</SAMP>
(左ブラケット、スペース、バックスラッシュ、"t"、
バックスラッシュ、"n"、右ブラケット
で、一つ以上のスペース、タブにマッチする正規表現)の間の違いは
重要である。これら両方の<CODE>FS</CODE>の値は、共に
フィールド分割をスペース、タブ、改行(の連続)で行う。
しかし、<CODE>FS</CODE>が<CODE>" "</CODE>であったとき、<CODE>awk</CODE>は
最初に、先頭や末尾で連続している空白のはぎ取りを行い、
それからフィールド分割を実行する。

</P>
<P>
例を挙げると、次のパイプラインでは<SAMP>`b'</SAMP>が出力される、

</P>

<PRE>
$ echo ' a b c d ' | awk '{ print $2 }'
-| b
</PRE>

<P>
しかし、次のパイプラインでは<SAMP>`a'</SAMP>が出力される
(それぞれの文字の回りにはスペースが付いていないことに注意)。

</P>

<PRE>
$ echo ' a  b  c  d ' | awk 'BEGIN { FS = "[ \t]+" }
&#62;                                  { print $2 }'
-| a
</PRE>

<P>
<A NAME="IDX196"></A>
この場合、第一フィールドは<STRONG>空</STRONG>(null、empty)である。

</P>
<P>
先頭や末尾にある空白は<CODE>$0</CODE>が再構成されたときには
いつでも取り除かれる。
例えば次のパイプラインで、

</P>

<PRE>
$ echo '   a b c d' | awk '{ print; $2 = $2; print }'
-|    a b c d
-| a b c d
</PRE>

<P>
最初の<CODE>print</CODE>文は読み込んだレコードをレコードの先頭にある空白も含め
てそのまま出力する。<CODE>$2</CODE>に対する代入は、<CODE>$1</CODE>から<CODE>$NF</CODE>まで
を<CODE>OFS</CODE>の値で分割されたものとして連結して<CODE>$0</CODE>を再構成する。先 
頭の空白は<CODE>$1</CODE>に注目したときには無視されているので、新しい<CODE>$0</CODE>
には含まれない。そして、最後の<CODE>print</CODE>文は新しい<CODE>$0</CODE>を出力する。

</P>


<H3><A NAME="SEC41" HREF="gawk_toc.html#SEC41">個々のキャラクタを別個のフィールドにする</A></H3>

<P>
<A NAME="IDX197"></A>
<A NAME="IDX198"></A>
レコード中の個々のキャラクタを別個にチェックしたいと思うことはままあるだ
ろう。<CODE>gawk</CODE>では、それを簡単に行える。単に空文字列(<CODE>""</CODE>)を
<CODE>FS</CODE>にセットするに代入すればよい。この場合、レコード中の個々の独立し
たキャラクタがそれぞれ一つのフィールドとなる。例を挙げると、

</P>

<PRE>
$ echo a b | gawk 'BEGIN { FS = "" }
&#62;                  { 
&#62;                      for (i = 1; i &#60;= NF; i = i + 1)
&#62;                          print "フィールド", i, "は", $i
&#62;                  }'
-| Field 1 is a
-| Field 2 is
-| Field 3 is b
</PRE>

<P>
この出力は以下のようになる。

</P>

<PRE>
フィールド 1 は a
フィールド 2 は
フィールド 3 は b
</PRE>

<P>
<A NAME="IDX199"></A>
伝統的に、<CODE>FS</CODE>が<CODE>""</CODE>にセットされているときの振る舞いは
未定義だった。この場合UNIXの<CODE>awk</CODE>は、単にレコード全体を
一つのフィールドであるように扱う(d.c.)。
<CODE>gawk</CODE>は互換モード(セクション <A HREF="gawk_15.html#SEC135">コマンドラインオプション</A>を参照)では、
<CODE>FS</CODE>が空文字列の場合にはこのような動作をするようになる。

</P>


<H3><A NAME="SEC42" HREF="gawk_toc.html#SEC42">コマンドラインで <CODE>FS</CODE> の設定をする</A></H3>
<P>
<A NAME="IDX200"></A>
<A NAME="IDX201"></A>
<A NAME="IDX202"></A>

</P>
<P>
<CODE>FS</CODE>はコマンドライン上でセットすることができる。
それには<SAMP>`-F'</SAMP>オプションを使用する。例を挙げよう。

</P>

<PRE>
awk -F, '<VAR>program</VAR>' <VAR>input-files</VAR>
</PRE>

<P>
この例では<CODE>FS</CODE>を<SAMP>`,'</SAMP>というキャラクタにセットしている。このオプ 
ションが大文字の<SAMP>`F'</SAMP>を使っていることに注意。これに似た<SAMP>`-f'</SAMP>とい 
うオプションは、<CODE>awk</CODE>プログラムが入っているファイルを指定するもので
ある。コマンドラインオプションの大小文字は区別されるので、<SAMP>`-F'</SAMP>と
<SAMP>`-f'</SAMP>という二つのオプションはまったく別のものである。これら両方のオプ
ションを同時に使って、変数<CODE>FS</CODE>に(セパレータを)セットするのと
<STRONG>同時に</STRONG><CODE>awk</CODE>プログラムをファイルから得ることができる。

</P>
<P>
<SAMP>`-F'</SAMP>の引数として使った値は、組込み変数<CODE>FS</CODE>に代入したときとまっ
たく同じように扱われる。どういうことかというと、もしフィールドセパレータ
がスペシャルキャラクタを含んでいたら、それを適切にエスケープしなければな
らないということである。例えば、<SAMP>`\'</SAMP>をフィールドセパレータとして使お
うとするなら、次のようにタイプする必要がある。

</P>

<PRE>
# FS = "\\" と同じ
awk -F\\\\ '...' files ...
</PRE>

<P>
<SAMP>`\'</SAMP>はシェルでクォートされるので、<CODE>awk</CODE>がみるのは<SAMP>`-F\\'</SAMP>に
なる。そして、<CODE>awk</CODE>はエスケープキャラクタ(セクション <A HREF="gawk_5.html#SEC27">エスケープシーケンス</A>を参照)
の処理を<SAMP>`\\'</SAMP>に対して行うので、最終的に得られるのは一つの<SAMP>`\'</SAMP>で
あり、これがフィールドセパレータとして使用される。

</P>
<P>
<A NAME="IDX203"></A>
特殊なケースとして、互換モード(セクション <A HREF="gawk_15.html#SEC135">コマンドラインオプション</A>を参照),
の場合、<SAMP>`-F'</SAMP>の引数が<SAMP>`t'</SAMP>であったときには<CODE>FS</CODE>にはタブキャラ
クタがセットされる。これは、<SAMP>`-F\t'</SAMP>とシェルのコマンドラインで指定し 
た場合、クォートが取れるので、<SAMP>`\'</SAMP>が削除されてしまう。そこで、
<CODE>awk</CODE>は<SAMP>`t'</SAMP>ではなく、ユーザーが本当に望んだタブによるフィールド
分割をするのである。もし本当に<SAMP>`t'</SAMP>でフィールド分割を行いたいのならば、
コマンドラインで<SAMP>`-v FS="t"'</SAMP> のようにする
(セクション <A HREF="gawk_15.html#SEC135">コマンドラインオプション</A>を参照)。

</P>
<P>
さて、ここで<CODE>/300/</CODE>というパターンと、そのアクションに<SAMP>`print $1'</SAMP>
を含む<TT>`baud.awk'</TT>というファイル名の<CODE>awk</CODE>プログラムを
使ってみよう。プログラムはこう。

</P>

<PRE>
/300/   { print $1 }
</PRE>

<P>
<CODE>FS</CODE>に<SAMP>`-'</SAMP>をセットし、<TT>`BBS-list'</TT>ファイルに
対して使ってみよう。以下のコマンドは、300ボーで運営されている
BBSの名前とその電話番号の最初の三桁を出力する。

</P>

<PRE>
$ awk -F- -f baud.awk BBS-list
-| aardvark     555
-| alpo
-| barfly       555
...
</PRE>

<P>
出力の二行目に注意。元のファイル
(セクション <A HREF="gawk_2.html#SEC9">例で使用するデータファイル</A>を参照),
の二行目はこうだった。

<PRE>
alpo-net     555-3412     2400/1200/300     A
</PRE>

<P>
期待している電話番号中にある<SAMP>`-'</SAMP>ではなく、システム名の一部で
ある<SAMP>`-'</SAMP>がフィールドセパレータとして扱われている。
これはあなたがレコードセパレータやフィールドセパレータを
選択するときには、注意しなければならないということの実例である。

</P>
<P>
多くのUNIXシステムでは、ユーザーはシステムのパスワードファイル中にユーザ
ー一人当り一行のエントリをそれぞれ所有している。そこにある情報はコロンに
よって区切られていて、最初のフィールドにはユーザーのログオン名が、二番目
のフィールドにはそのユーザーの暗号化されたパスワードがある。パスワードフ
ァイルのエントリはおおむね次のようなものである。

</P>

<PRE>
arnold:xyzzy:2076:10:Arnold Robbins:/home/arnold:/bin/sh
</PRE>

<P>
次のプログラムはシステムのパスワードファイルを検索して、パスワードが設定
されていないエントリを出力する。

</P>

<PRE>
awk -F: '$2 == ""' /etc/passwd
</PRE>



<H3><A NAME="SEC43" HREF="gawk_toc.html#SEC43">フィールド分割のまとめ</A></H3>

<P>
<A NAME="IDX204"></A>
<A NAME="IDX205"></A>
POSIXの標準に従えば、<CODE>awk</CODE>はレコードを読み込んだときにフィールドの 
分割をするように動作することになっている。これはレコードの読み込みが終わ
った後で<CODE>FS</CODE>の値を変更できるということであり、フィールドの値(どのよ
うに分割されたか、ということ)は新しいものではなく、古い変更前の<CODE>FS</CODE>
の値を反映したものであるべきであるということである。

</P>
<P>
<A NAME="IDX206"></A>
<A NAME="IDX207"></A>
<A NAME="IDX208"></A>
しかし、多くの<CODE>awk</CODE>処理系でこの動作をしておらず、実際にフィールドが
参照されるまで分割を遅らせている。この場合、フィールドは<STRONG>新しい</STRONG>
<CODE>FS</CODE>の値を使って分割されるのだ!(d.c.)この振る舞いは調べるのが難しい。
以下の例はこれら二つのやり方の違いを説明するものである(この<CODE>sed</CODE><A NAME="FOOT7" HREF="gawk_foot.html#FOOT7">(7)</A>コマンドは<TT>`/etc/passwd'</TT>の最初の一行
だけを出力する)。

</P>

<PRE>
sed 1q /etc/passwd | awk '{ FS = ":" ; print $1 }'
</PRE>

<P>
これは

</P>

<PRE>
root
</PRE>

<P>
間違った実装の<CODE>awk</CODE>では大概こうなるだろう。
一方<CODE>gawk</CODE>は次のように出力するだろう。

</P>

<PRE>
root:nSijPlPhZZwgE:0:0:Root:/:
</PRE>

<P>
以下に、<CODE>FS</CODE>の値によってフィールド分割がどのように
行われるかを簡単にまとめた(<SAMP>`=='</SAMP>は"等しい"ことを
示す)。

</P>
<DL COMPACT>

<DT><CODE>FS == " "</CODE>
<DD>
フィールドは空白の連続によって区切られる。このとき先頭の空白および
末尾の空白は無視される。これはデフォルトである。

<DT><CODE>FS == <VAR>any other single character</VAR></CODE>
<DD>
フィールドは指定されたキャラクタによって分割される。
このキャラクタが連続している場合は、空のフィールドを区切ることになり、
レコードの先頭や末尾で連続した場合でも同様である。
このキャラクタは正規表現のメタキャラクタであっても良い。
これはエスケープする必要はない。

<DT><CODE>FS == <VAR>regexp</VAR></CODE>
<DD>
フィールドは<VAR>regexp</VAR>にマッチした文字列によって
分割される。先頭、および末尾で<VAR>regexp</VAR>にマッチしたものは
空フィールドを区切る。

<DT><CODE>FS == ""</CODE>
<DD>
レコード中の各キャラクタが独立したフィールドになる。
</DL>



<H2><A NAME="SEC44" HREF="gawk_toc.html#SEC44">固定長データの読み込み</A></H2>

<P>
(このセクションでは、先進的な、実験的機能について説明している。もしあな 
たが<CODE>awk</CODE>初心者なら、初めて読んだときにはここを飛ばしたくなるかもし
れない)

</P>
<P>
<CODE>gawk</CODE> 2.13 で新たに、幅が固定されていてセパレータを持っていないフ 
ィールドを扱うための機能を導入した。そこで想定されているデータは典型的に
は古いFORTRANプログラムに対する数値の入力として、あるいは他のプログラム 
の入力として扱われることを考慮していないプログラムの出力の二つのうちのい
ずれかだろう。

</P>
<P>
後で挙げる例は、全てのカラムが可変数のスペースを使用して整列されていて、
空のフィールドがスペースで構成されているデータのテーブルである。現実に、
<CODE>awk</CODE>の通常の<CODE>FS</CODE>に基づいて行うフィールド分割はこの様なケース
ではうまく働かない。<CODE>awk</CODE>プログラム中で<CODE>$0</CODE>に対して
<CODE>substr</CODE>をくり返し呼ぶことで実現できるが
(セクション <A HREF="gawk_13.html#SEC126">Built-in Functions for String Manipulation</A>を参照)、
これはポータブルであっても、 awkward であり、大きなフィールド番号では非
効率的なやり方である。

</P>
<P>
入力レコードを固定幅のフィールドに分割するときには、組み込み変数<CODE>FIELDWIDTHS</CODE>
に設定されたスペースで区切られた数字の並びで指定する。並びのそれぞれの数字
は、フィールドの幅をフィールドの間のカラムを含めて指定している。もし、フィー
ルドの間のカラムを無視したいのであれば、後続を無視するようなフィールドの分割
をする幅を指定することもできる。

</P>
<P>
次のデータは<CODE>w</CODE>ユーティリティの出力である。これはまた<CODE>FIELDWIDTHS</CODE>
の使い方を説明するのにちょうどよい。

</P>

<PRE>
 10:06pm  up 21 days, 14:04,  23 users
User     tty       login  idle   JCPU   PCPU  what
hzuo     ttyV0     8:58pm            9      5  vi p24.tex 
hzang    ttyV3     6:37pm    50                -csh 
eklye    ttyV5     9:53pm            7      1  em thes.tex 
dportein ttyV6     8:17pm  1:47                -csh 
gierd    ttyD3    10:00pm     1                elm 
dave     ttyD4     9:47pm            4      4  w 
brent    ttyp0    26Jun91  4:46  26:46   4:41  bash 
dave     ttyq4    26Jun9115days     46     46  wnewmail
</PRE>

<P>
次のプログラムは先ほどのデータを入力とし、アイドルタイムを秒に変換して入
力データの最初の二つのフィールドと、計算した時間を出力する(このプログラ 
ムはまだ説明されていない<CODE>awk</CODE>の機能をいくつか使っている)。

</P>

<PRE>
BEGIN  { FIELDWIDTHS = "9 6 10 6 7 7 35" }
NR &#62; 2 {
    idle = $4
    sub(/^  */, "", idle)   # 先頭の連続するスペースをはぎとる
    if (idle == "")
        idle = 0
    if (idle ~ /:/) {
        split(idle, t, ":")
        idle = t[1] * 60 + t[2]
    }
    if (idle ~ /days/)
        idle *= 24 * 60 * 60
 
    print $1, $2, idle
}
</PRE>

<P>
プログラムの実行結果は次の通り。

</P>

<PRE>
hzuo      ttyV0  0
hzang     ttyV3  50
eklye     ttyV5  0
dportein  ttyV6  107
gierd     ttyD3  1
dave      ttyD4  0
brent     ttyp0  286
dave      ttyq4  1296000
</PRE>

<P>
別の（より現実的であろう）固定幅の例となる入力データは、投票用紙の山からの
入力だろう。合衆国の一部では、投票者は投票をコンピュータカードのパンチされた
穴を選択することで行う。これらのカードは投票がどの候補者に行われたか、ある
いはどの欄が選択されたかを数えるのに使われる。投票者が一部の投票を行わなかっ
た場合、対応するカードのカラムは空である。<CODE>awk</CODE>プログラムはその様なデー
タを処理するために、 <CODE>FIELDWIDTHS</CODE> 機能を使ってデータを単純に読むこと
ができる(もちろん、カードリーダー付きのシステムで<CODE>gawk</CODE>を動かすように
するのは別の話だ!)。

</P>

<P>
ある値を<CODE>FS</CODE>に代入すると、<CODE>gawk</CODE>はフィールド分割を<CODE>FS</CODE>を 
使って行うように戻る。これを<SAMP>`FS=FS'</SAMP>を使ってやれば、<CODE>FS</CODE>の値が 
何であるかを知ることなしにできる。

</P>
<P>
この機能は未だ実験的なものであり、改良されることだろう。<CODE>gawk</CODE>は
<CODE>FIELDWIDTH</CODE>に設定されている内容を使うときにその値が正しいものであ
るかどうかのチェックをしないということにとくに注意すること。

</P>


<H2><A NAME="SEC45" HREF="gawk_toc.html#SEC45">複数行レコード</A></H2>

<P>
<A NAME="IDX209"></A>
<A NAME="IDX210"></A>
<A NAME="IDX211"></A>
<A NAME="IDX212"></A>
一部のデータベースでは、一つの情報のエントリを一行で保持できない。
この様な場合に、複数行レコードを使うことができる。

</P>
<P>
そういうデータを扱うための最初のステップは扱うデータのフォーマットの選択で
ある。レコードが一行であると定義されないときにどのようにレコードを決定する
か? どうやってレコードの分割を行うか?

</P>
<P>
一つの手段としてはレコードを分割するのに、あまり使われないようなキャラクタか
文字列を使う。ということがある。例えばフォームフィードのコード (<CODE>awk</CODE>で
はCのように、<CODE>\f</CODE>と記述する)をファイルをページを一つのレコードとして分割
するために使うことができるだろう。そうするには変数<CODE>RS</CODE> に<CODE>"\f"</CODE>を
セットすればよい。他の、レコード中のデータの一部分として同じ程度にあまり使わ
れていないキャラクタを使うこともできるだろう。

</P>
<P>
他のやり方としては空行でレコードを分割するというものがある。
他のやり方としては空行でレコードを分割するという手段がある。特別な場合とし
て、空文字列を<CODE>RS</CODE>にセットすると、それはレコードの区切りとして一行以上
の空行をでレコードを分割するという事を示す。もし、<CODE>RS</CODE>に空文字列をセッ
トすると、レコードは常に最初の空行に出会ったところで終わる。そして、次のレ
コードは空行でない行がきたところでスタートする。どれだけ空行が続いているの
かは関係なく、単に一つのレコードセパレータとして認識される(ファイルの終端
はレコードセパレータとして認識される)。

</P>
<P>
<A NAME="IDX213"></A>
<A NAME="IDX214"></A>
<SAMP>`RS = ""'</SAMP> としたときと同じ効果を<CODE>"\n\n+"</CODE>を<CODE>RS</CODE>にセットす
ることによって得ることができる。この正規表現はレコードの終端にある改行に
マッチし、一行以上の空白行がレコードの後に続く。それに加えて、正規表現は
常にマッチする最長のパターンを選択する
(セクション <A HREF="gawk_5.html#SEC31">How Much Text Matches?</A>を参照)。
したがって、次のレコードは空行でない行がくるまでスタートしない。どれだけ
空行が続いてあるかは関係なく、単に一つのレコードセパレータとして認識され
る。

</P>
<P>
<A NAME="IDX215"></A>
<SAMP>`RS = ""'</SAMP>と<SAMP>`RS = "\n\n+"'</SAMP>には重要な違いがある。最初のものは、 
入力データファイル中の先頭にある改行は無視され、最後のレコードの後に空行
がない場合には、最後の改行がレコードから剥ぎ取られる。二番目のものでは、
このような特殊な処理は行われない(d.c.)。

</P>
<P>
ここまでで入力がレコードに分割された。第二のステップはレコード中のフィー
ルドをどう分割するか、という事である。フィールドを分割する別のやり方とし
ては、通常の方法で各行をフィールドに分割するというものである。これは特殊
機能の結果、デフォルトで生じることである。<CODE>RS</CODE> に空文字列が設定され
ている場合、改行は常にフィールドセパレータとして動作する。これは、
<CODE>FS</CODE>に設定されている値によるフィールド分割に加えられる形で行われる。

</P>
<P>
この特別な例外を取り入れることになった元々の動機は、デフォルトの場合に使い易
い動作をするようにするためである (i.e., <CODE>FS == " "</CODE>)。この機能は、
ユーザーが本当は改行をフィールド分割のためのキャラクタとして使いたくないときに、
それを防ぐ手段がないので問題となる。しかしながら、 <CODE>split</CODE>関数を使って
手動で分割を行なうことで望む結果を得ることができる
(セクション <A HREF="gawk_13.html#SEC126">Built-in Functions for String Manipulation</A>を参照).

</P>
<P>
もう一つの方法は一行を一つのフィールドとして出力する。というものがある。
それを実行するには変数<CODE>FS</CODE> に <CODE>"\n"</CODE>という文字列をセットすれば良い
(これは、改行にマッチする単純な正規表現である)。

</P>
<P>
このやり方で作成されたデータファイルの現実的なサンプルはメイリングリスト
だろう。それぞれのエントリは空行で分割される。もし<TT>`addresses'</TT>という
ファイル名のメイリングリストを持っていたら、こんな感じだろう。

</P>

<PRE>
Jane Doe
123 Main Street
Anywhere, SE 12345-6789

John Smith
456 Tree-lined Avenue
Smallville, MW 98765-4321

...
</PRE>

<P>
このファイルを処理する簡単なプログラムはこういったものだろう

</P>

<PRE>
# addrs.awk -- 簡単なメイリングリストプログラム

# レコードは空行によって区切られる。
# 各行は一つのフィールドとなる。
BEGIN { RS = "" ; FS = "\n" }

{
      print "Name is:", $1
      print "Address is:", $2
      print "City and State are:", $3
      print ""
}
</PRE>

<P>
このプログラムを実行した結果は次のようになる。

</P>

<PRE>
$ awk -f addrs.awk addresses
-| Name is: Jane Doe
-| Address is: 123 Main Street
-| City and State are: Anywhere, SE 12345-6789
-| 
-| Name is: John Smith
-| Address is: 456 Tree-lined Avenue
-| City and State are: Smallville, MW 98765-4321
-| 
...
</PRE>

<P>
アドレスリストを扱うより本格的なプログラムは
セクション <A HREF="gawk_17.html#SEC168">郵便の宛て名を出力する</A>を参照.
にある。

</P>
<P>
以下に挙げる例は、<CODE>RS</CODE>の値によってレコードがどのように
分割されるかをまとめたものである(<SAMP>`=='</SAMP>は"'等しい'ということである)。

</P>
<DL COMPACT>

<DT><CODE>RS == "\n"</CODE>
<DD>
レコードは改行キャラクタ(<SAMP>`\n'</SAMP>)で分割される。
言い換えると、データファイルの各行が空行も含めて、
独立したレコードとなる。

<DT><CODE>RS == <VAR>任意の一文字</VAR></CODE>
<DD>
レコードは指定されたキャラクタにより分割される。
このキャラクタが連続している場合には、空のレコードを区切っていると
みなされる。

<DT><CODE>RS == ""</CODE>
<DD>
空行の連続によってレコードを分割する。改行は
<CODE>FS</CODE>に設定されているものに加えて、常にフィールドセパレータとなる、
ファイルの先頭や末尾にある改行は無視される。

<DT><CODE>RS == <VAR>regexp</VAR></CODE>
<DD>
</DL>
<P>
<VAR>regexp</VAR>にマッチした文字列によってレコードが分割される。
先頭や末尾にある<VAR>regexp</VAR>は空レコードを区切るとみなされる。

</P>
<P>
<A NAME="IDX216"></A>
すべてのケースにおいて、<CODE>gawk</CODE>は<CODE>RT</CODE>に
<CODE>RS</CODE>で指定されたものにマッチしたテキストをセットする。

</P>


<H2><A NAME="SEC46" HREF="gawk_toc.html#SEC46"><CODE>getline</CODE>を使った入力</A></H2>

<P>
<A NAME="IDX217"></A>
<A NAME="IDX218"></A>
<A NAME="IDX219"></A>
<A NAME="IDX220"></A>
<A NAME="IDX221"></A>
これまで私達は<CODE>awk</CODE>の主入力ストリームから入力データを得ていた。それ
は標準入力(通常はターミナル、ときとして他のプログラムの出力)やコマンドラ
インで指定したファイルであった。<CODE>awk</CODE>言語は<CODE>getline</CODE>と呼ばれる
特殊な組込みコマンドを持っており、これは明確に制御された元での入力読み取
りに使うことができる。

</P>



<H3><A NAME="SEC47" HREF="gawk_toc.html#SEC47">Introduction to <CODE>getline</CODE></A></H3>

<P>
このコマンドは非常に複雑であり、初心者はあまり使うべきではない。この章が入
力に関してのものであるのでここで記述している。以下に挙げる例はまだ説明され
ていないものが含まれている <CODE>getline</CODE>コマンドの説明である。従って、この
マニュアルの残りの部分を読んで<CODE>awk</CODE>がどのように動作するかの知識を十分
得た後に、ここに戻って<CODE>getline</CODE>コマンドを学ぶのが良いだろう。

</P>
<P>
<A NAME="IDX222"></A>
<A NAME="IDX223"></A>
<A NAME="IDX224"></A>
<CODE>getline</CODE>はレコードが見付かれば1を返し、ファイルの終端に達したときには
0を返す。もし、レコードの読み込みでなんらかのエラーが発生したり、
ファイルがオープンできなかったりした場合には<CODE>getline</CODE>は-1を
返す。このとき<CODE>gawk</CODE>は<CODE>ERRNO</CODE>という変数にエラーが発生したことを
表わす文字列をセットする。

</P>
<P>
次の例では、<VAR>command</VAR> はシェルコマンドを表す文字列である。

</P>


<H3><A NAME="SEC48" HREF="gawk_toc.html#SEC48">引数なしで<CODE>getline</CODE>を使う</A></H3>

<P>
<CODE>getline</CODE> コマンドはカレント入力ファイルから入力するときには引数を省略
することができる。この場合、入力レコードはフィールドに分割される。この
<CODE>getline</CODE> の使い方は、カレント入力レコードに対する処理は終わったが、何
か特別な処理を次のレコードに対してその時点で処理を行いたい、というときに便
利である。たとえば

</P>

<PRE>
awk '{
     if ((t = index($0, "/*")) != 0) {
          # tが1だったら、この値は""になる
          tmp = substr($0, 1, t - 1)
          u = index(substr($0, t + 2), "*/")
          while (u == 0) {
               if (getline &#60;= 0) {
                    m = "unexpected EOF or error"
                    m = (m ": " ERRNO)
                    print m &#62; "/dev/stderr"
                    exit
               }
               t = -1
               u = index($0, "*/")
          }
          # */がファイルの終端にあるとsubstrは""になる
          $0 = tmp substr($0, t + u + 3)
     }
     print $0
}'
</PRE>

<P>
この<CODE>awk</CODE>プログラムは入力から<SAMP>`/* ... */'</SAMP>というCスタイルのコメ
ントを取り除く。<SAMP>`print $0'</SAMP>を他の文に置き換えることによって、より複雑な
処理をコメントアウトされた入力に対して、ある正規表現にマッチするかどうかを探
すなどして行うことができる。(このプログラムには隠された問題点がある---それは
一つのコメント終了と開始とが同じ行にあるときにうまく働かない
ということである。

</P>

<P>
この形式の<CODE>getline</CODE>コマンドは<CODE>NF</CODE>
(フィールドの数。セクション <A HREF="gawk_6.html#SEC35">フィールドの検査</A>を参照)、
<CODE>NR</CODE>(それまでに読んだレコードの数。
セクション <A HREF="gawk_6.html#SEC34">入力をレコードへと分割をするやりかた</A>を参照)、
<CODE>FNR</CODE>(現在の入力ファイルから読み込んだレコードの数)、
<CODE>$0</CODE>に新しい値をセットする。

</P>
<P>
<A NAME="IDX225"></A>
<STRONG>ノート:</STRONG> 新しい<CODE>$0</CODE>の値は、後に続いてあるルールのパターン部とテ
ストするために使われる。このとき、元々の<CODE>$0</CODE>の値は失われる。対照的に
<CODE>next</CODE>文で新しいレコードを読んだときは、即座に通常通りの処理を始め、プ
ログラムの最初のルールから処理を始める(d.c.)。
セクション <A HREF="gawk_10.html#SEC105">The <CODE>next</CODE> Statement</A>を参照.

</P>


<H3><A NAME="SEC49" HREF="gawk_toc.html#SEC49">変数にgetlineの結果を格納する</A></H3>

<P>
<SAMP>`getline <VAR>var</VAR>'</SAMP> を使って、
<CODE>awk</CODE>の入力からの次のレコードを変数<VAR>var</VAR>に
読み込むことができる。他の処理は行われない。

</P>
<P>
例えば、次の行がコメントであるとか特殊な文字列であって、
何のルールも実行することなしにそれを読みたいようなことを想定しよう。
この形式の<CODE>getline</CODE>は、その様な行を読み込みと
変数への格納を
<CODE>awk</CODE>の行読み込み--ルールのチェックというループが
チェックすることなしにできるのである。

</P>
<P>
次の例は、入力された二行毎にその行を入れ替える。というものである。入力として

</P>

<PRE>
wan
tew
free
phore
</PRE>

<P>
というものがあると、出力は

</P>

<PRE>
tew
wan
phore
free
</PRE>

<P>
こうなる。以下はプログラムである。

</P>

<PRE>
awk '{
     if ((getline tmp) &#62; 0) {
          print tmp
          print $0
     } else
          print $0
}'
</PRE>

<P>
ここでは<CODE>getline</CODE>関数は変数<CODE>NR</CODE> and <CODE>FNR</CODE>に(もちろん
<VAR>var</VAR>にも)セットする目的で使われている。レコードはフィールドに分割はさ
れず、したがってフィールドの値(<CODE>$0</CODE> も含めて)と、<CODE>NF</CODE>の値は変更
されない。

</P>


<H3><A NAME="SEC50" HREF="gawk_toc.html#SEC50"><CODE>getline</CODE>を使ったファイルからの入力</A></H3>

<P>
<A NAME="IDX226"></A>
<A NAME="IDX227"></A>
<SAMP>`getline &#60; <VAR>file</VAR>'</SAMP>を使って、
次のレコードを<VAR>file</VAR>というファイルから読み込むことができる。
この<VAR>file</VAR>はファイル名として特定できる文字列の値を持った式である。 
<SAMP>`&#60; <VAR>file</VAR>'</SAMP>は異なった場所から直接入力を行うので <STRONG>リダイレクト</STRONG>
と呼ばれる。

</P>
<P>
例えば、次のプログラムはレコードの入力を、カレント入力からのレコードの最初の
フィールドが10であったときに、<TT>`secondary.input'</TT>というファイルから行う。

</P>

<PRE>
awk '{
    if ($1 == 10) {
         getline &#60; "secondary.input"
         print
    } else
         print
}'
</PRE>

<P>
通常の入力ストリームを使わないので、<CODE>NR</CODE>と<CODE>FNR</CODE>の値は変更されない。
しかし、読み込まれたレコードは通常のルールに従ってフィールドに分割され、
<CODE>$0</CODE> および、その他のフィールドの値は変更される。もちろん<CODE>NF</CODE>の値
もその例外ではない。

</P>
<P>
POSIXに従えば、<SAMP>`getline &#60; <VAR>expression</VAR>'</SAMP> は
<VAR>expression</VAR>中に<SAMP>`$'</SAMP>以外の演算子が括弧に囲まれないで
現れたときには曖昧となる。たとえば<SAMP>`getline &#60; dir "/" file'</SAMP> 
は連接演算子が括弧に囲まれずに現れており、曖昧になっている。
そしてこれは、他の<CODE>awk</CODE>処理系でも問題なく使えるように
したいのなら、<SAMP>`getline &#60; (dir "/" file)'</SAMP> と記述すべきである。

</P>


<H3><A NAME="SEC51" HREF="gawk_toc.html#SEC51"><CODE>getline</CODE>を使ってファイルから変数へ格納</A></H3>

<P>
<SAMP>`getline <VAR>var</VAR> &#60; <VAR>file</VAR>'</SAMP>を使って
ファイル<VAR>file</VAR>から読み込み、変数<VAR>var</VAR>に
それをセットする、先に述べたように、
<VAR>file</VAR>は読み込みに使用するファイルを指定する文字列式である。

</P>
<P>
この使い方の<CODE>getline</CODE>はどの組み込み変数も変更せず、レコードのフィール
ドへの分解も行われない。ただ単に<VAR>var</VAR>だけが変わる。

</P>

<P>
例えば、次のプログラムでは入力ファイルを出力するが、入力中に
<SAMP>`@include <VAR>filename</VAR>'</SAMP>と書かれたレコードがあったときに、その様
なレコードを<VAR>filename</VAR>というファイルの内容で置き換える。

</P>

<PRE>
awk '{
     if (NF == 2 &#38;&#38; $1 == "@include") {
          while ((getline line &#60; $2) &#62; 0)
               print line
          close($2)
     } else
          print
}'
</PRE>

<P>
これは特別な入力ファイルの名前がプログラム中に書かれていない例である。この
例は、<SAMP>`@include'</SAMP>がある行の二番目のフィールドで指定されるファイルから
データを持ってくる。

</P>
<P>
<CODE>close</CODE>関数は入力中にある<SAMP>`@include'</SAMP>で指定されるファイルの中に同
じものが二度以上指定されているものがあったとしてもきちんと動作することを保
証するために呼ばれている。 
セクション <A HREF="gawk_7.html#SEC67">Closing Input and Output Files and Pipes</A>を参照.

</P>
<P>
このプログラムで一つ欠けているのは、本当のマクロプロセッサではできるような
ネストした<SAMP>`@include'</SAMP>文(インクルードファイルの中にある
<SAMP>`@include'</SAMP>)を処理できないという点である。
ネストした<SAMP>`@include'</SAMP>文を処理できるプログラムは
セクション <A HREF="gawk_17.html#SEC173">ライブラリを使う簡単な方法</A>を参照。

</P>


<H3><A NAME="SEC52" HREF="gawk_toc.html#SEC52"><CODE>getline</CODE>を使ったパイプからの入力</A></H3>

<P>
<A NAME="IDX228"></A>
<A NAME="IDX229"></A>
コマンドの出力を<STRONG>パイプ</STRONG>を通じて<CODE>getline</CODE>を
<SAMP>`<VAR>command</VAR> | getline'</SAMP>のように使って受けることができる。パイプは
単にあるプログラムの出力を他の入力にリンクするだけである。このケースでは、
<VAR>command</VAR> という文字列はシェルコマンドとして実行され、その出力がパイプ
を通じて<CODE>awk</CODE>の入力とされる。この例の<CODE>getline</CODE>ではパイプからレコー
ドを読み込んでいる。

</P>
<P>
例えば次のプログラムは入力を出力にコピーするが、ある行が<SAMP>`@execute'</SAMP> で
始まっていると、その行を<SAMP>`@execute'</SAMP>に続く部分をシェルのコマンドとして
実行して、入力をその結果に置き換える。

</P>

<PRE>
awk '{
     if ($1 == "@execute") {
          tmp = substr($0, 10)
          while ((tmp | getline) &#62; 0)
               print
          close(tmp)
     } else
          print
}'
</PRE>

<P>
<CODE>close</CODE> 関数は入力中の<SAMP>`@execute'</SAMP>のある行で指定されるコマンドに二
つ以上の同一のコマンドが指定されたときに、一回毎にそのコマンドを実行する様
にさせるために呼び出される。
セクション <A HREF="gawk_7.html#SEC67">Closing Input and Output Files and Pipes</A>を参照.

</P>
<P>
入力として以下のものを与える。

</P>

<PRE>
foo
bar
baz
@execute who
bletch
</PRE>

<P>
プログラムの出力はこうなる。

</P>

<PRE>
foo
bar
baz
arnold     ttyv0   Jul 13 14:22
miriam     ttyp0   Jul 13 14:23     (murphy:0)
bill       ttyp1   Jul 13 14:23     (murphy:0)
bletch
</PRE>

<P>
このプログラムは<CODE>who</CODE>コマンドを実行し、結果を出力する(もしこのプロ
グラムがやっていることを自分でやろうとしたら、その結果は異なったものとなる
だろう。誰がシステムにログインしているかで変わるからだ)。

</P>
<P>
この形式の<CODE>getline</CODE>では、レコードをフィールドに分割し、<CODE>NF</CODE>をセット
して<CODE>$0</CODE>を再計算する。このとき、<CODE>NR</CODE> と<CODE>FNR</CODE>は変更しない。

</P>
<P>
POSIXに従えば、<SAMP>`getline | <VAR>expression</VAR>'</SAMP> は
<VAR>expression</VAR>中に<SAMP>`$'</SAMP>以外の演算子が括弧に囲まれないで
現れたときには曖昧となる。たとえば<SAMP>`"echo " "date" | getline'</SAMP> 
は連接演算子が括弧に囲まれずに現れており、曖昧になっている。
そしてこれは、他の<CODE>awk</CODE>処理系でも問題なく使えるように
したいのなら、<SAMP>`("echo " "date") | getline'</SAMP> と記述すべきである
(<CODE>gawk</CODE>はこの件に関しては正しく動作するのだが、それに依存すべき
ではない。いずれにしろかっこによって読みやすいものになるのだ)。

</P>


<H3><A NAME="SEC53" HREF="gawk_toc.html#SEC53"><CODE>getline</CODE>を使ってパイプからの内容を変数に格納する</A></H3>

<P>
<SAMP>`<VAR>command</VAR> | getline <VAR>var</VAR>'</SAMP>を使ったとき、
<VAR>command</VAR>の出力は
パイプを通じて<CODE>getline</CODE>に渡り、さらに変数<VAR>var</VAR>
に格納される。例えば次に挙げるプログラムでは <CODE>date</CODE> ユーティリティを使用
して日付と時刻を読み込み、それを<CODE>current_time</CODE>という変数に格納し、さら
に表示している。

</P>

<PRE>
awk 'BEGIN {
     "date" | getline current_time
     close("date")
     print "Report printed on " current_time
}'
</PRE>

<P>
この使い方の<CODE>getline</CODE>では、どの組み込み変数も変更されず、レコードの
フィールド分割も行われない。

</P>



<H3><A NAME="SEC54" HREF="gawk_toc.html#SEC54">各種<CODE>getline</CODE> のまとめ</A></H3>

<P>
これらすべての<CODE>getline</CODE>において、<CODE>$0</CODE>や<CODE>NF</CODE>が更新されて
も、(読み込まれた)レコードは<CODE>awk</CODE>プログラムのすべてのパターンでテス
トが行われるということはなく、<CODE>awk</CODE>がメイン処理ループで通常通りレコ
ードを読み込んだかのように動作する。しかし新しいレコードは残りのルールに
対してはテストが行われる。

</P>
<P>
<A NAME="IDX230"></A>
<A NAME="IDX231"></A>
<A NAME="IDX232"></A>
<A NAME="IDX233"></A>
<A NAME="IDX234"></A>
先に述べたように
(セクション <A HREF="gawk_6.html#SEC54">各種<CODE>getline</CODE> のまとめ</A>を参照)、
多くの
<CODE>awk</CODE>処理系では、一つの<CODE>awk</CODE>プログラムで開くことのできる
パイプの数はたったの一つである! <CODE>gawk</CODE>ではこのような制限はなく、使
用しているオペレーティングシステムが許す限りのパイプをオープンすることが
できる。

</P>
<P>
<A NAME="IDX235"></A>
<A NAME="IDX236"></A>
<A NAME="IDX237"></A>
<A NAME="IDX238"></A>
getlineを、<CODE>BEGIN</CODE>ルールの中でリダイレクトをせずに使った場合、
興味深い副作用が発生する。リダイレクトされていない<CODE>getline</CODE>は
コマンドラインで指定されたデータファイルから読み込むので、最初の<CODE>getlile</CODE>
は<CODE>awk</CODE>に<CODE>FILENAME</CODE>の値をセットさせる。通常、
(<CODE>BEGINルール</CODE>では)コマンドラインで指定されたデータファイルを
処理しないので<CODE>FILENAME</CODE>は<CODE>BEGIN</CODE>ルールでは値を持たない(d.c.)。
(セクション <A HREF="gawk_9.html#SEC93">特殊パターン<CODE>BEGIN</CODE>と<CODE>END</CODE></A>を参照と
セクション <A HREF="gawk_11.html#SEC110">情報を伝達する組込み変数</A>を参照.)

</P>
<P>
以下に六種類の<CODE>getline</CODE>の使い方とそれぞれの使い方でセットされる組込み
変数を一覧にした。

</P>
<DL COMPACT>

<DT><CODE>getline</CODE>
<DD>
<CODE>$0</CODE>, <CODE>NF</CODE>, <CODE>FNR</CODE>, <CODE>NR</CODE>をセットする。

<DT><CODE>getline <VAR>var</VAR></CODE>
<DD>
<VAR>var</VAR>, <CODE>FNR</CODE>, <CODE>NR</CODE>をセットする。

<DT><CODE>getline &#60; <VAR>file</VAR></CODE>
<DD>
<CODE>$0</CODE>, <CODE>NF</CODE>をセットする。

<DT><CODE>getline <VAR>var</VAR> &#60; <VAR>file</VAR></CODE>
<DD>
<VAR>var</VAR>をセットする。

<DT><CODE><VAR>command</VAR> | getline</CODE>
<DD>
<CODE>$0</CODE>, <CODE>NF</CODE>をセットする。

<DT><CODE><VAR>command</VAR> | getline <VAR>var</VAR></CODE>
<DD>
<VAR>var</VAR>をセットする。
</DL>

<HR>
移動先 <A HREF="gawk_1.html">先頭</A>, <A HREF="gawk_5.html">前</A>, <A HREF="gawk_7.html">次</A>, <A HREF="gawk_25.html">末尾</A> セクション, <A HREF="gawk_toc.html">目次</A>.
</BODY>
</HTML>
